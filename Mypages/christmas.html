<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åœ£è¯å‘Šç™½ - æ‰‹åŠ¿äº’åŠ¨ç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Cinzel', serif; }
        canvas { display: block; }

        /* UI å åŠ å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #video-container {
            position: absolute; top: 20px; right: 20px;
            width: 200px; height: 150px; border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 10px; overflow: hidden; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* æ“ä½œæŒ‡å— */
        #guide {
            position: absolute; bottom: 30px; left: 30px;
            color: #ffd700; background: rgba(0,0,0,0.6);
            padding: 15px; border-radius: 8px; pointer-events: auto;
        }

        /* å‘Šç™½ä¿¡å° */
        #envelope-wrapper {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
        }
        #envelope-wrapper.active { transform: translate(-50%, -50%) scale(1); }

        .envelope {
            width: 300px; height: 200px; background: #b01a1a;
            position: relative; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .letter {
            position: absolute; bottom: 10px; left: 10px; right: 10px;
            height: 180px; background: #fdf5e6; padding: 20px;
            text-align: center; color: #333; transition: transform 0.5s;
        }
        .open .letter { transform: translateY(-100px); }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed; inset: 0; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #ffd700; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loader">
    <h2>æ­£åœ¨è¿æ¥é­”æ³•æ˜Ÿç©º...</h2>
    <p>è¯·å…è®¸å¼€å¯æ‘„åƒå¤´ä»¥ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶</p>
</div>

<div id="ui-layer">
    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="guide">
        <h3 style="margin-top:0">æ‰‹åŠ¿é­”æ³•æŒ‡å—</h3>
        <ul style="font-size: 0.9em; padding-left: 20px;">
            <li>âœŠ æ¡æ‹³ï¼šå‡èšåœ£è¯æ ‘</li>
            <li>ğŸ–ï¸ å¼ æ‰‹ï¼šç²’å­æ¼«å¤©é£èˆ</li>
            <li>â¤ï¸ æ¯”å¿ƒï¼šå¼€å¯å‘Šç™½ä¿¡</li>
        </ul>
    </div>

    <div id="envelope-wrapper">
        <div class="envelope" onclick="this.classList.toggle('open')">
            <div class="letter">
                <h3>To My Love</h3>
                <p>åœ¨è¿™ä¸ªæ˜Ÿå…‰ç¿çƒ‚çš„å¤œæ™šï¼Œ<br>æ„¿ä½ çš„ä¸–ç•Œæ°¸è¿œå……æ»¡æš–æ„ã€‚</p>
                <p style="font-size: 0.8em; color: #888;">ç‚¹å‡»ä¿¡å°å…³é—­</p>
            </div>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, treeParticles, handLandmarker;
    let video = document.getElementById('webcam');
    let lastVideoTime = -1;
    let currentGesture = 'TREE';

    // --- åˆå§‹åŒ– Three.js ---
    function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // åˆ›å»ºç²’å­æ ‘
        createTree();
        
        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        window.addEventListener('resize', onWindowResize);
    }

    function createTree() {
        const count = 6000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        
        // åˆå§‹ä½ç½®ï¼šåœ£è¯æ ‘å½¢æ€
        for (let i = 0; i < count; i++) {
            updateParticleToTree(positions, i);
            colors[i*3] = 1; 
            colors[i*3+1] = 0.84; 
            colors[i*3+2] = 0; // é‡‘è‰²
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 0.04,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        treeParticles = new THREE.Points(geometry, material);
        scene.add(treeParticles);
    }

    function updateParticleToTree(array, i) {
        const t = Math.random();
        const angle = t * Math.PI * 16;
        const radius = (1 - t) * 2.5;
        array[i*3] = Math.cos(angle) * radius;
        array[i*3+1] = t * 6 - 3;
        array[i*3+2] = Math.sin(angle) * radius;
    }

    // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
    async function initMediaPipe() {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
        });
        
        startCamera();
    }

    function startCamera() {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                document.getElementById('loader').style.display = 'none';
                animate();
            });
        });
    }

    // --- æ ¸å¿ƒæ‰‹åŠ¿åˆ¤å®š ---
    function detectGesture(landmarks) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];

        const dist = (p1, p2) => Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
        
        // æ¯”å¿ƒé€»è¾‘ï¼šæ‹‡æŒ‡å°–é è¿‘é£ŸæŒ‡å°–ï¼Œä¸”ä¸­æŒ‡/æ— åæŒ‡/å°æŒ‡å¼¯æ›²
        const isPinching = dist(thumbTip, indexTip) < 0.05;
        const isOthersCurled = middleTip.y > landmarks[10].y && ringTip.y > landmarks[14].y;

        if (isPinching && isOthersCurled) {
            // è¿›ä¸€æ­¥åˆ¤æ–­ï¼šé£ŸæŒ‡æ ¹éƒ¨ä½ç½®ä¸æŒ‡å°–ä½ç½®å½¢æˆçš„å¤¹è§’ï¼ˆç®€åŒ–ç‰ˆï¼‰
            if (indexTip.y > landmarks[6].y) return 'HEART'; 
            return 'PINCH';
        }

        // å¼ æ‰‹ï¼šæ‰€æœ‰æ‰‹æŒ‡å°–é«˜äºå…¶å…³èŠ‚
        if (indexTip.y < landmarks[6].y && middleTip.y < landmarks[10].y) return 'SCATTER';

        return 'TREE';
    }

    // --- åŠ¨ç”»å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);
        
        if (video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            const detections = handLandmarker.detectForVideo(video, performance.now());
            
            if (detections.landmarks.length > 0) {
                currentGesture = detectGesture(detections.landmarks[0]);
                updateUI(currentGesture);
            }
        }

        updateParticles();
        renderer.render(scene, camera);
    }

    function updateUI(gesture) {
        const envelope = document.getElementById('envelope-wrapper');
        if (gesture === 'HEART') {
            envelope.classList.add('active');
        } else if (gesture === 'SCATTER') {
            envelope.classList.remove('active');
        }
    }

    function updateParticles() {
        const positions = treeParticles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length / 3; i++) {
            if (currentGesture === 'SCATTER') {
                // å‘å¤–é£æ•£
                positions[i*3] += (Math.random() - 0.5) * 0.2;
                positions[i*3+1] += (Math.random() - 0.5) * 0.2;
                positions[i*3+2] += (Math.random() - 0.5) * 0.2;
            } else {
                // ç¼“æ…¢å›å½’æ ‘å½¢æ€ï¼ˆç®€åŒ–çš„å¹³æ»‘é€»è¾‘ï¼‰
                const t = (i / (positions.length / 3));
                const angle = t * Math.PI * 16 + (performance.now() * 0.001); // å¢åŠ æ—‹è½¬æ„Ÿ
                const radius = (1 - (i / (positions.length / 3))) * 2.5;
                
                const targetX = Math.cos(angle) * radius;
                const targetY = t * 6 - 3;
                const targetZ = Math.sin(angle) * radius;

                positions[i*3] += (targetX - positions[i*3]) * 0.05;
                positions[i*3+1] += (targetY - positions[i*3+1]) * 0.05;
                positions[i*3+2] += (targetZ - positions[i*3+2]) * 0.05;
            }
        }
        treeParticles.geometry.attributes.position.needsUpdate = true;
        treeParticles.rotation.y += 0.002;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // å¯åŠ¨
    initScene();
    initMediaPipe();

</script>
</body>
</html>